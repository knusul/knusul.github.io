<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[TDD or not to Be]]></title>
  <link href="http://knusul.github.io/atom.xml" rel="self"/>
  <link href="http://knusul.github.io/"/>
  <updated>2016-10-06T20:16:35+02:00</updated>
  <id>http://knusul.github.io/</id>
  <author>
    <name><![CDATA[Jakub Nieznalski]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Multiple Ssh-ids With Github]]></title>
    <link href="http://knusul.github.io/blog/2016/10/05/using-multiple-ssh-keys-with-github/"/>
    <updated>2016-10-05T21:33:37+02:00</updated>
    <id>http://knusul.github.io/blog/2016/10/05/using-multiple-ssh-keys-with-github</id>
    <content type="html"><![CDATA[<p>Sometimes I need to interact with github using multiple ssh-keys.
This is how I configure git to do it:</p>

<p>Lets create new rsa key</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ssh-keygen</span></code></pre></td></tr></table></div></figure>


<p>Then configure new key in github</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  cat ~/.ssh/new_id_rsa.pub</span></code></pre></td></tr></table></div></figure>


<p>When you try to push ssh-key-agent will use your old key. Create/Modify the file ~/.ssh/config</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Host github.com-new_id_rsa
</span><span class='line'>  HostName github.com
</span><span class='line'>  User git
</span><span class='line'>  IdentityFile ~/.ssh/new_id_rsa</span></code></pre></td></tr></table></div></figure>


<p>Next open <code>.git/config</code> in your project and change url accordingly:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>url = git@github.com-new-id-rsa:YOUR_USERNAME/YOUR_REPOSITORY.github.git</span></code></pre></td></tr></table></div></figure>


<p>Now in your project directory you should be able to git push</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Consuming Google AdWords Api With Akka Spray]]></title>
    <link href="http://knusul.github.io/blog/2016/05/02/consuming-google-adwords-api-with-akka-spray/"/>
    <updated>2016-05-02T19:45:22+02:00</updated>
    <id>http://knusul.github.io/blog/2016/05/02/consuming-google-adwords-api-with-akka-spray</id>
    <content type="html"><![CDATA[<p>Google AdWords Api is a very tricky beast when under heavy use.
When you send too many requests per minute you get banned for 30s. Moreover the amount of queries that you cam perform varies durning the day.
I found consuming Google AdWords Api a perfect use case for Scala Akka and Spray frameworks.
Please take into account I&rsquo;m beginer Scala programmer and it&rsquo;s one of my very first projects in that language.
We will build Spray Api that will accept json list of keywords, adWords locationId and languageId and we return the keywords enchanced with targetingIdea and trafficEstiamtor service data.
We use throttle actor(<a href="http://doc.akka.io/docs/akka/snapshot/contrib/throttle.html">http://doc.akka.io/docs/akka/snapshot/contrib/throttle.html</a>) to limit amount of queries to adWords Api.</p>

<ol>
<li>Start new Spray project like described at: <code>https://github.com/spray/spray-template/tree/on_spray-can_1.3</code></li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> git clone git://github.com/spray/spray-template.git adwords-project</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Add the following libraries to build.sbt</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> "com.typesafe.akka" %% "akka-contrib" % akkaV,
</span><span class='line'> "io.spray" %%  "spray-json" % "1.3.2",
</span><span class='line'> "com.google.api-ads" % "ads-lib" % "2.11.0" exclude("commons-beanutils", "commons-beanutils"),
</span><span class='line'> "com.google.api-ads" % "adwords-axis" % "2.11.0" exclude("commons-beanutils", "commons-beanutils"),
</span><span class='line'> "commons-beanutils" % "commons-beanutils" % "1.9.2",
</span><span class='line'> "com.google.http-client" % "google-http-client-gson" % "1.21.0",
</span><span class='line'> "com.google.inject" % "guice" % "4.0",
</span><span class='line'> "org.slf4j" % "slf4j-simple" % "1.7.5",
</span><span class='line'> "javax.activation"  % "activation"  % "1.1.1"
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Write JSON converter
We want to return json, and we need to convert adWords api response to json
In order to do that we write json converter:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>implicit object AnyJsonFormat extends JsonFormat[Any] {
</span><span class='line'>    def write(x: Any): JsValue = x match {
</span><span class='line'>      case n: Int =&gt; JsNumber(n)
</span><span class='line'>      case l: Long =&gt; JsNumber(l)
</span><span class='line'>      case d: Double =&gt; JsNumber(d)
</span><span class='line'>      case f: Float =&gt; JsNumber(f.toDouble)
</span><span class='line'>      case s: String =&gt; JsString(s)
</span><span class='line'>      case x: Seq[_] =&gt; seqFormat[Any].write(x)
</span><span class='line'>      case m: Map[_, _] if m.isEmpty =&gt; JsObject(Map[String, JsValue]())
</span><span class='line'>      // Get the type of map keys from the first key, translate the rest the same way
</span><span class='line'>      case m: Map[_, _] =&gt; m.keys.head match {
</span><span class='line'>        case sym: Symbol =&gt;
</span><span class='line'>          val map = m.asInstanceOf[Map[Symbol, _]]
</span><span class='line'>          val pairs = map.map { case (sym, v) =&gt; (sym.name -&gt; write(v)) }
</span><span class='line'>          JsObject(pairs)
</span><span class='line'>        case s: String =&gt; mapFormat[String, Any].write(m.asInstanceOf[Map[String, Any]])
</span><span class='line'>        case a: Any =&gt;
</span><span class='line'>          val map = m.asInstanceOf[Map[Any, _]]
</span><span class='line'>          val pairs = map.map { case (sym, v) =&gt; (sym.toString -&gt; write(v)) }
</span><span class='line'>          JsObject(pairs)
</span><span class='line'>      }
</span><span class='line'>      case a: Array[_] =&gt; seqFormat[Any].write(a.toSeq)
</span><span class='line'>      case true        =&gt; JsTrue
</span><span class='line'>      case false       =&gt; JsFalse
</span><span class='line'>      case p: Product  =&gt; seqFormat[Any].write(p.productIterator.toSeq)
</span><span class='line'>      case null        =&gt; JsNull
</span><span class='line'>      case x           =&gt; JsString(x.toString)
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    def read(value: JsValue) = value match {
</span><span class='line'>      case JsNumber(n) =&gt; n.intValue()
</span><span class='line'>      case JsString(s) =&gt; s
</span><span class='line'>      case JsTrue      =&gt; true
</span><span class='line'>      case JsFalse     =&gt; false
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<p>We add the code above the routes into HttpService Trait
4. Add a route
Our only action will accept list of keywords and respond with enchanced data from targetingIdeaService</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>post {
</span><span class='line'>    requestInstance { req =&gt;
</span><span class='line'>      val request = req.entity.asString.parseJson.convertTo[KeywordsRequest]
</span><span class='line'>      complete {
</span><span class='line'>        AdwordsCaller.handler(request.keywords, request.location_id, request.language_id).mapTo[Map[String, Map[String, Any]]]
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Implement an action
Adwords Caller implements Akka actor system that throttles requests to google limited to specific timeframe</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>case class CallAdwords(keywords: Array[String], location_id: Integer, langauge_id: Integer, session: AdWordsSession, AdWordsServices: AdWordsServices)
</span><span class='line'>case object CallAdwords
</span><span class='line'>
</span><span class='line'>class AdwordsCaller extends Actor {
</span><span class='line'>  def receive = {
</span><span class='line'>    case CallAdwords(keywords, location_id, language_id, session, adWordsServices) =&gt; sender ! GetAdwordsStats.run(keywords, location_id, language_id, session, adWordsServices)
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>object AdwordsCaller {
</span><span class='line'>
</span><span class='line'>  val system = ActorSystem()
</span><span class='line'>  import system.dispatcher
</span><span class='line'>  implicit val timeout = Timeout(60.second)
</span><span class='line'>
</span><span class='line'>  val adwordsCaller = system.actorOf(Props[AdwordsCaller])
</span><span class='line'>  val throttler = system.actorOf(Props(classOf[TimerBasedThrottler], 200 msgsPer 60.seconds))
</span><span class='line'>  throttler ! SetTarget(Some(adwordsCaller))
</span><span class='line'>
</span><span class='line'>  def handler(keywords: Array[String], location_id: Integer, language_id: Integer): Future[Any] = {
</span><span class='line'>    val result = (throttler ? CallAdwords(keywords, location_id, language_id, null, null))
</span><span class='line'>    return result
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Call AdWords Api
Finally GetAdwordsStats calls GoogleAdwords Api IdeaQuery and TrafficEstimation Query and combines results for each keyword</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
<span class='line-number'>136</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> def run(keywords: Array[String], location_id: Integer, language_id: Integer, session: AdWordsSession, adWordsServices: AdWordsServices): Map[String, Map[String, Any]] = {
</span><span class='line'>      val oAuth2Credential = new OfflineCredentials.Builder().forApi(Api.ADWORDS)
</span><span class='line'>    .fromFile("./ads.properties")
</span><span class='line'>    .build()
</span><span class='line'>    .generateCredential()
</span><span class='line'>  val logger = LoggerFactory.getLogger(classOf[AdWordsServices])
</span><span class='line'>  val session = new AdWordsSession.Builder().fromFile().withOAuth2Credential(oAuth2Credential)
</span><span class='line'>    .build()
</span><span class='line'>  val adWordsServices = new AdWordsServices()
</span><span class='line'>    
</span><span class='line'>    val ideaResults = runTargetingIdeaQuery(adWordsServices, session, keywords, location_id, language_id)
</span><span class='line'>    val traficEstimatorResults = runTrafficEstimatorQuery(adWordsServices, session, keywords, location_id, language_id)
</span><span class='line'>    var resultKeywords = Map[String, Map[String, Any]]()
</span><span class='line'>    for (keyword &lt;- keywords) {
</span><span class='line'>      resultKeywords = resultKeywords + (keyword.toLowerCase() -&gt; Map())
</span><span class='line'>      for ((ideaKey, ideaValue) &lt;- ideaResults(keyword.toLowerCase())) {
</span><span class='line'>        var newVal = resultKeywords(keyword.toLowerCase()) + (ideaKey -&gt; ideaValue)
</span><span class='line'>        resultKeywords = resultKeywords + (keyword.toLowerCase() -&gt; newVal)
</span><span class='line'>      }
</span><span class='line'>      for ((ideaKey, ideaValue) &lt;- traficEstimatorResults(keyword)) {
</span><span class='line'>        var newVal = resultKeywords(keyword.toLowerCase()) + (ideaKey -&gt; ideaValue)
</span><span class='line'>        resultKeywords = resultKeywords + (keyword.toLowerCase() -&gt; newVal)
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return resultKeywords
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  def runTargetingIdeaQuery(adWordsServices: AdWordsServices, session: AdWordsSession, keywords: Array[String], location_id: Integer, language_id: Integer): Map[String, Map[String, Any]] = {
</span><span class='line'>
</span><span class='line'>    val targetingIdeaService = adWordsServices.get(session, classOf[TargetingIdeaServiceInterface])
</span><span class='line'>    val selector = new TargetingIdeaSelector()
</span><span class='line'>    selector.setRequestType(RequestType.STATS)
</span><span class='line'>    selector.setIdeaType(IdeaType.KEYWORD)
</span><span class='line'>
</span><span class='line'>    selector.setRequestedAttributeTypes(Array(AttributeType.KEYWORD_TEXT, AttributeType.SEARCH_VOLUME,
</span><span class='line'>      AttributeType.CATEGORY_PRODUCTS_AND_SERVICES, AttributeType.AVERAGE_CPC, AttributeType.COMPETITION))
</span><span class='line'>    val paging = new Paging()
</span><span class='line'>    paging.setStartIndex(0)
</span><span class='line'>    paging.setNumberResults(2500)
</span><span class='line'>    selector.setPaging(paging)
</span><span class='line'>    val relatedToQuerySearchParameter = new RelatedToQuerySearchParameter()
</span><span class='line'>    relatedToQuerySearchParameter.setQueries(keywords)
</span><span class='line'>
</span><span class='line'>    val languageParameter = new LanguageSearchParameter()
</span><span class='line'>    val language = new Language()
</span><span class='line'>    language.setId(language_id.toLong)
</span><span class='line'>    languageParameter.setLanguages(Array(language))
</span><span class='line'>    val locationParameter = new LocationSearchParameter()
</span><span class='line'>    val location = new Location()
</span><span class='line'>    location.setId(location_id.toLong)
</span><span class='line'>    locationParameter.setLocations(Array(location))
</span><span class='line'>
</span><span class='line'>    selector.setSearchParameters(Array(relatedToQuerySearchParameter, languageParameter, locationParameter))
</span><span class='line'>    val page = targetingIdeaService.get(selector)
</span><span class='line'>    var resultKeywords = Map[String, Map[String, Any]]()
</span><span class='line'>    if (page.getEntries != null && page.getEntries.length &gt; 0) {
</span><span class='line'>
</span><span class='line'>      for (targetingIdea &lt;- page.getEntries) {
</span><span class='line'>        val data = Maps.toMap(targetingIdea.getData)
</span><span class='line'>        val keyword = data.get(AttributeType.KEYWORD_TEXT).asInstanceOf[StringAttribute]
</span><span class='line'>        val categories = data.get(AttributeType.CATEGORY_PRODUCTS_AND_SERVICES).asInstanceOf[IntegerSetAttribute]
</span><span class='line'>        var categoriesString = "(none)"
</span><span class='line'>        if (categories != null && categories.getValue != null) {
</span><span class='line'>          categoriesString = categories.getValue.toJson.prettyPrint
</span><span class='line'>        }
</span><span class='line'>        val averageMonthlySearches = data.get(AttributeType.SEARCH_VOLUME).asInstanceOf[LongAttribute]
</span><span class='line'>          .getValue
</span><span class='line'>        val cpc = data.get(AttributeType.AVERAGE_CPC).asInstanceOf[MoneyAttribute]
</span><span class='line'>
</span><span class='line'>        val money = cpc.getValue
</span><span class='line'>        var averageCpc = 0.0
</span><span class='line'>        if (money != null) {
</span><span class='line'>          averageCpc = money.getMicroAmount.toDouble / 1000000.0
</span><span class='line'>        }
</span><span class='line'>        var result: Map[String, Any] = Map("search_volume" -&gt; averageMonthlySearches.toString(), "categories" -&gt; categoriesString, "average_cpc" -&gt; averageCpc.toString())
</span><span class='line'>        resultKeywords = resultKeywords + (keyword.getValue() -&gt; result)
</span><span class='line'>      }
</span><span class='line'>    } else {
</span><span class='line'>      println("No related keywords were found.")
</span><span class='line'>    }
</span><span class='line'>    return resultKeywords
</span><span class='line'>  }
</span><span class='line'>  def runTrafficEstimatorQuery(adWordsServices: AdWordsServices, session: AdWordsSession, keywords: Array[String], location_id: Integer, language_id: Integer): Map[String, Map[String, Any]] = {
</span><span class='line'>
</span><span class='line'>    val keywordEstimateRequests = new ArrayList[KeywordEstimateRequest]()
</span><span class='line'>
</span><span class='line'>    for (keywordText &lt;- keywords) {
</span><span class='line'>      val keyword = new Keyword();
</span><span class='line'>      keyword.setText(keywordText);
</span><span class='line'>      keyword.setMatchType(KeywordMatchType.BROAD);
</span><span class='line'>      val keywordEstimateRequest = new KeywordEstimateRequest();
</span><span class='line'>      keywordEstimateRequest.setKeyword(keyword);
</span><span class='line'>      keywordEstimateRequests.add(keywordEstimateRequest);
</span><span class='line'>    }
</span><span class='line'>    val adGroupEstimateRequests = new ArrayList[AdGroupEstimateRequest]()
</span><span class='line'>    val adGroupEstimateRequest = new AdGroupEstimateRequest()
</span><span class='line'>    adGroupEstimateRequest.setKeywordEstimateRequests(keywordEstimateRequests.toArray(Array()))
</span><span class='line'>    adGroupEstimateRequest.setMaxCpc(new Money(null, 600000L))
</span><span class='line'>    adGroupEstimateRequests.add(adGroupEstimateRequest)
</span><span class='line'>
</span><span class='line'>    var campaignEstimateRequests = Array[CampaignEstimateRequest]()
</span><span class='line'>    val campaignEstimateRequest = new CampaignEstimateRequest()
</span><span class='line'>    campaignEstimateRequest.setAdGroupEstimateRequests(adGroupEstimateRequests.toArray(Array()))
</span><span class='line'>
</span><span class='line'>    val location = new Location()
</span><span class='line'>    location.setId(location_id.toLong)
</span><span class='line'>    val language = new Language()
</span><span class='line'>    language.setId(language_id.toLong)
</span><span class='line'>    campaignEstimateRequests = campaignEstimateRequests :+ campaignEstimateRequest
</span><span class='line'>    val selector = new TrafficEstimatorSelector()
</span><span class='line'>    selector.setCampaignEstimateRequests(campaignEstimateRequests)
</span><span class='line'>
</span><span class='line'>    val trafficEstimatorService = adWordsServices.get(session, classOf[TrafficEstimatorServiceInterface])
</span><span class='line'>    val result = trafficEstimatorService.get(selector)
</span><span class='line'>
</span><span class='line'>    var resultKeywords = Map[String, Map[String, Any]]()
</span><span class='line'>    var index = 0
</span><span class='line'>    for (
</span><span class='line'>      campaignEstimate &lt;- result.getCampaignEstimates; adGroupEstimate &lt;- campaignEstimate.getAdGroupEstimates;
</span><span class='line'>      keywordWithEstimate &lt;- adGroupEstimate.getKeywordEstimates.zip(keywords)
</span><span class='line'>    ) {
</span><span class='line'>      var keyword = keywordWithEstimate._2
</span><span class='line'>      var keywordEstimate = keywordWithEstimate._1
</span><span class='line'>      val min = keywordEstimate.getMin
</span><span class='line'>      val max = keywordEstimate.getMax
</span><span class='line'>      val avg_total_cost = (max.getTotalCost.getMicroAmount + min.getTotalCost.getMicroAmount) / 2000000.0
</span><span class='line'>      var result: Map[String, Any] = Map("avg_ctr" -&gt; (min.getClickThroughRate + max.getClickThroughRate) / 2,
</span><span class='line'>        "keyword" -&gt; keyword, "avg_total_cost" -&gt; avg_total_cost.toString(),
</span><span class='line'>        "clicks_per_day" -&gt; Array(min.getClicksPerDay, max.getClicksPerDay),
</span><span class='line'>        "total_cost" -&gt; Array(min.getTotalCost.getMicroAmount / 1000000, max.getTotalCost.getMicroAmount / 1000000),
</span><span class='line'>        "average_position" -&gt; Array(min.getAveragePosition, max.getAveragePosition))
</span><span class='line'>      resultKeywords = resultKeywords + (keyword -&gt; result)
</span><span class='line'>    }
</span><span class='line'>    return resultKeywords
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging With Docker]]></title>
    <link href="http://knusul.github.io/blog/2016/02/22/logging-with-docker/"/>
    <updated>2016-02-22T16:59:05+01:00</updated>
    <id>http://knusul.github.io/blog/2016/02/22/logging-with-docker</id>
    <content type="html"><![CDATA[<p>There is great article how to configure centralized logging for docker with cloudwatch:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>https://blogs.aws.amazon.com/application-management/post/TxFRDMTMILAA8X/Send-ECS-Container-Logs-to-CloudWatch-Logs-for-Centralized-Monitoring</span></code></pre></td></tr></table></div></figure>


<p>It assumes that the application can send logs to other container running rsyslog.
We will extend the example to work with locally saved logs.
In order to make it work we need to:</p>

<p>1) Create one container that will configure cloudwatch and rsyslog that listen to the events.</p>

<p>2) Configure rsyslog on second devise that will listen to file changes in logs folder and will send logs to second rsyslog service running on another machine</p>

<p>I decided to create another rsyslog agent running together with my application because I&rsquo;m reusing the docker cloudwatch container.</p>

<p>First lets remove /dev/xconsole from rsyslog config. It breaks the rsyslog because most docker images does not have dev/xconsole.
Open aws cloudwatch ecs project and edit Dockerfile</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RUN rm /etc/rsyslog.d/50-default.conf</span></code></pre></td></tr></table></div></figure>


<p>Next we need to configure rsyslog on our app machine. We need rsyslog version > 8.15.0 to use wildcard imfile as a log source(see rsyslog.conf):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RUN apt-get update
</span><span class='line'>RUN apt-get -y install libestr-dev  liblogging-stdlog-dev  libgcrypt-dev uuid-dev libjson0-dev  libz-dev
</span><span class='line'>RUN wget http://www.rsyslog.com/files/download/rsyslog/rsyslog-8.16.0.tar.gz
</span><span class='line'>RUN tar xvzf rsyslog-8.16.0.tar.gz
</span><span class='line'>RUN cd rsyslog-8.16.0 && ./configure --enable-imfile && make && make install
</span><span class='line'>COPY rsyslog.conf /etc/rsyslog.conf
</span><span class='line'>RUN pip install supervisor
</span><span class='line'>COPY supervisord.conf /usr/local/etc/supervisord.conf
</span><span class='line'>CMD ["/usr/local/bin/supervisord"]</span></code></pre></td></tr></table></div></figure>


<p>supervisord.conf is pretty simply:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[supervisord]
</span><span class='line'>nodaemon=true
</span><span class='line'>
</span><span class='line'>[program:rsyslogd]
</span><span class='line'>command=/usr/local/sbin/rsyslogd -n
</span><span class='line'>
</span><span class='line'>[program:awslogs]
</span><span class='line'>command=your-app-with-logs
</span></code></pre></td></tr></table></div></figure>


<p>rsyslog.conf sends logs written to file to rsyslog on machine running cloudwatch agent</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>module(load="imfile")
</span><span class='line'>input(type="imfile" file="/usr/src/app/logs/location/*.log" tag="spider_locations" facility="local6")</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Modifing AWS Gateway Output Parameters]]></title>
    <link href="http://knusul.github.io/blog/2016/02/01/modifing-aws-gateway-output-parameters/"/>
    <updated>2016-02-01T17:05:00+01:00</updated>
    <id>http://knusul.github.io/blog/2016/02/01/modifing-aws-gateway-output-parameters</id>
    <content type="html"><![CDATA[<p>Maybe you want to hide unnecessery parameters from api or you want to modify the keys. It&rsquo;s straightforawrd with amazon gateway but it took me some time to find how to do it.
Go to AWS Gateway -> Your api -> Integration Response -> Response template and change &ldquo;passthru&rdquo; to sth like</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#set($inputRoot = $input.path('$'))
</span><span class='line'>{
</span><span class='line'>  "listings" : $inputRoot.items
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<p>This will strip all other keys in a response dict and replace it with one key that&rsquo;s the value of original &lsquo;items&rsquo; key. Whoila!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raspberry PI as a Home Hotspot Powered by Telekom Hotspot]]></title>
    <link href="http://knusul.github.io/blog/2016/01/28/raspberry-pi-as-a-home-hotspot-powered-by-telekom-hotspot/"/>
    <updated>2016-01-28T07:50:15+01:00</updated>
    <id>http://knusul.github.io/blog/2016/01/28/raspberry-pi-as-a-home-hotspot-powered-by-telekom-hotspot</id>
    <content type="html"><![CDATA[<p>If you are living in Germany and you have phone plan covering free Telekom Hotspot usage probably you wondered, like me if its possible to broadcast signal from hotspot to home.
One function that prohibits us from using simple reapeter is the fact that Telekom hotspot has html username/password authentication. The hotspot deuthenticates the user when inactive and when token expires.
The idea is to put 2 WIFI cards into raspberry PI. One will receive signal from hotspot. On another we will configure hostapd and dhcp server to broadacast signal at home. We will write simple script that authenticates user in Telekom hotspot using curl.</p>

<ol>
<li>Step is to get raspberry PI. I&rsquo;m using the B+ model that has 4 USB exists and microSD slot.</li>
<li>Install Raspbian OS</li>
<li>Configure raspberry PI</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get update
</span><span class='line'>sudo apt-get -y install hostapd isc-dhcp-server iptables wpa_supplicant</span></code></pre></td></tr></table></div></figure>


<p>edit the following files: <code>/etc/hostapd/hostapd.conf</code>,  <code>/etc/dhcp/dhcpd.conf</code>, <code>/etc/default/isc-dhcp-server</code>, <code>/etc/network/interfaces</code>:
4. Enable packet forwarding on start by adding the line &ldquo;net.ipv4.ip_forward=1&rdquo; to  &ldquo; /etc/sysctl.conf&rdquo;
5. Configure IP-Tables(I assume wlan1 is a interface connected to Telekom Hotspot.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iptables -t nat -A POSTROUTING -o wlan1 -j MASQUERADE</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iptables -A FORWARD -i wlan1 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iptables -A FORWARD -i wlan0 -o wlan1 -j ACCEPT </span></code></pre></td></tr></table></div></figure>


<ol>
<li>Save the rules:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sh -c iptables-save &gt; /etc/iptables.ipv4.nat</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Run dhcp server and hostapd:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo update-rc.d hostapd enable</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo update-rc.d isc-dhcp-server enable </span></code></pre></td></tr></table></div></figure>


<ol>
<li>You should be able now to connect to raspberry PI wifi network(wlan0) from home. But no internet yet.</li>
<li>Now connect to telekom hotspot:</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo iwconfig wlan1 essid Telekom; sudo dhcpclient wlan1</span></code></pre></td></tr></table></div></figure>


<ol>
<li>Move to your laptop and perform http Login with your Telekom username and password. In Chrome open console and in a network tab find the post to Telekom gateway.
Click on that request and click &ldquo;save as curl command&rdquo; paste the command to a script and save on raspberry.
Then write short script that will check internet connection and if there is no it will reauthenticate. Sth like this</li>
</ol>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/bin/sh
</span><span class='line'>while [ 1 ]; do
</span><span class='line'>    sudo ping www.google.com -c 1 && echo "OK" || curl -v 'https://hotspot.t-mobile.net/wlan/rest/login' -H 'Origin: https://hotspot.t-mobile.net' -H 'Accept-Encoding: gzip, deflate' -H 'Accept-Language: en-US,en;q=0.8' -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2490.86 Safari/537.36' -H 'Content-Type: application/json;charset=UTF-8' -H 'Accept: application/json, text/plain, */*' -H 'Referer: https://hotspot.t-mobile.net/TD/hotspot/de_DE/index.html?origurl=http%3A%2F%2Fwww.kimeta.de%2FOfferDetail.aspx&ts=1451396580457' -H 'Cookie: 06847EADCEBFD2E920C1F12378924815.P2; oam.Flash.RENDERMAP.TOKEN=118ogwrec4' -H 'Connection: keep-alive' --data-binary '{"username":"phone-number@t-mobile.de","password":"password","rememberMe":true}' --compressed
</span><span class='line'>    sleep 1
</span><span class='line'>    done</span></code></pre></td></tr></table></div></figure>


<p>Put the script in monit or run with nohup in raspberry pi
<img src="http://knusul.github.io/images/raspberry.jpeg"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AWS Lambda. The Bad Parts]]></title>
    <link href="http://knusul.github.io/blog/2016/01/05/aws-lambda-the-bad-parts/"/>
    <updated>2016-01-05T16:31:55+01:00</updated>
    <id>http://knusul.github.io/blog/2016/01/05/aws-lambda-the-bad-parts</id>
    <content type="html"><![CDATA[<p>Amazon about their Lambda service: &ldquo;AWS Lambda is a zero-administration compute platform for back-end web developers that runs your code for you in the AWS cloud and provides you with a fine-grained pricing structure&rdquo;
I spend some time with a microservice-awslambda architecture. Here I share numerous problems I encountered:
1) Testing/Staging env requires seperate lambda function. We can not deploy same lambda function with different version to different APIs.
2) The Lambda environment is archaic: Node v0.9 without ECMA6 support and Python 2.7.
3) Difficult to deploy Python with shared libraries. When deploying python function with precompiled shared library we have to build it on same architecture like AWS Lambda, otherwise it won&rsquo;t work. We can not simply deploy liblxml build on MacOSX. In order to compile linked libraries it&rsquo;s necessery to build them on ec2 instance and then deploy to Lambda. Seems like too much work for simple task.</p>

<h1>Conclusion</h1>

<p>There are great benefits in an architecture build on Lambda functions. Unfortunately it comes in a costs.
It might work well for very simple services but when we need to create anything more complicated than &lsquo;hello world&rsquo; its wise to move to other solution. Maybe Dockeris a thing to go. If you want to share your thoughts about Lambda AWS architecture please comment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comparison of PDF Generation Libraries]]></title>
    <link href="http://knusul.github.io/blog/2015/06/26/comparison-of-pdf-generation-libraries/"/>
    <updated>2015-06-26T17:48:34+02:00</updated>
    <id>http://knusul.github.io/blog/2015/06/26/comparison-of-pdf-generation-libraries</id>
    <content type="html"><![CDATA[<p>Recently I investigated the possibilities of PDF generation from doc(x)
documents. It came up that its not that trivial.
The goal is to have separate application that will have api to perform conversions.</p>

<h1>Example Usage:</h1>

<p>Post: docx2pdf.tmh.io/templates/create?filename=name.docx # status: ok
Get: doc2pdf.tmh.io/templates/1/pdf?placeholder1=value1&amp;placeholder2=value2  #document.pdf</p>
]]></content>
  </entry>
  
</feed>
